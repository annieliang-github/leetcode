Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work.  
// Encodes a tree to a single string.
public String serialize(TreeNode root) {
        if (root == null) return "";
        StringBuilder sb = new StringBuilder();
        sb.append("["); //左半个中括号
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()) {            
            TreeNode node = queue.poll();
            if (node != null) {
                sb.append("" + node.val); // 转成String
                queue.offer(node.left); // 此题不用判断如果非null再offer
                queue.offer(node.right);
            } else sb.append("null");
            sb.append(","); //最后会多一个逗号，但是没关系deserialize的时候唯一解
        }
        sb.append("]");
        return sb.toString();
}
// Decodes your encoded string to tree.
public TreeNode deserialize(String data) {
        if (data == "") return null;
        // 去掉前后的中括号，然后split逗号
        String[] array = data.substring(1, data.length() - 1).split(",");
        TreeNode root = new TreeNode(Integer.parseInt(array[0])); //第一个数是root
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int index = 1; //root的index为1
        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            if (!array[index].equals("null")) { // 不为null的话，入队
                node.left = new TreeNode(Integer.parseInt(array[index]));
                queue.offer(node.left);
            }
            index++;
            if (!array[index].equals("null")) { // 不为null的话，入队
                node.right = new TreeNode(Integer.parseInt(array[index]));
                queue.offer(node.right);
            }
            index++;
        }
        return root;
}
